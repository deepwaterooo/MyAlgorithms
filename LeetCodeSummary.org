#+latex_class: book
#+latex_header: \lstset{language=Java,numbers=left,numberstyle=\tiny,basicstyle=\ttfamily\small,tabsize=4,frame=none,escapeinside=``,extendedchars=false,keywordstyle=\color{blue!70},commentstyle=\color{red!55!green!55!blue!55!},rulesepcolor=\color{red!20!green!20!blue!20!}}
#+title: LeetCode Summary
#+author: deepwaterooo

* 数组 Array
** Easy
*** Remove Element	
*** Remove Duplicates from Sorted Array
*** Plus One
*** Pascal's Triangle
*** Pascal's Triangle II
*** Merge Sorted Array	
*** Majority Element	
** Medium
*** Two Sum
*** 3Sum Closest
*** Container With Most Water
*** Set Matrix Zeroes	
*** Minimum Path Sum	
*** Search Insert Position
*** Unique Paths
*** Search in Rotated Sorted Array II
*** Search for a Range
*** Search a 2D Matrix
*** Rotate Image
*** 3Sum
*** 4Sum
*** Remove Duplicates from Sorted Array II
*** Unique Paths II
*** Next Permutation
*** Missing Ranges 	
*** Find Minimum in Rotated Sorted Array
*** Combination Sum II
*** Two Sum II - Input array is sorted
*** Triangle
*** Maximum Subarray
*** Maximum Product Subarray
*** Word Search
*** Combination Sum	
*** Subsets
*** Subsets II
*** Jump Game
*** Spiral Matrix
*** Spiral Matrix II
*** Sort Colors
*** Find Peak Element
** Hard
*** Trapping Rain Water
*** Find Minimum in Rotated Sorted Array II
*** Insert Interval
*** Jump Game II
*** Longest Consecutive Sequence
*** First Missing Positive	
*** Median of Two Sorted Arrays
*** Merge Intervals
*** Word Ladder II
*** Best Time to Buy and Sell Stock III
*** Search in Rotated Sorted Array
** Others
- Construct Binary Tree from Inorder and Postorder Traversal
- Construct Binary Tree from Preorder and Inorder Traversal
- Best Time to Buy and Sell Stock
  [[Best Time to Buy and Sell Stock]]
- Best Time to Buy and Sell Stock II	
  [[Best Time to Buy and Sell Stock II]]
- Largest Rectangle in Histogram
  [[Largest Rectangle in Histogram]]
- Maximal Rectangle
  [[Maximum Rectangle]]

* 字符串 String
** Easy
*** Valid Parentheses
*** Add Binary	
*** Compare Version Numbers
*** Count and Say	
*** Longest Common Prefix
*** Roman to Integer	
*** Valid Palindrome	
*** Read N Characters Given Read4
*** Implement strStr()	
*** ZigZag Conversion	
*** String to Integer (atoi)	
*** Length of Last Word
** Medium
*** Restore IP Addresses
*** Anagrams
*** Integer to Roman
*** Multiply Strings
*** One Edit Distance
*** Longest Palindromic Substring
*** Letter Combinations of a Phone Number
*** Decode Ways
*** Longest Substring Without Repeating Characters
*** Generate Parentheses
*** Reverse Words in a String
*** Simplify Path
** Hard
*** Edit Distance
*** Minimum Window Substring
*** Longest Substring with At Most Two Distinct Characters 	
*** Read N Characters Given Read4 II - Call multiple times
*** Regular Expression Matching
*** Interleaving String
*** Wildcard Matching
*** Scramble String	
*** Distinct Subsequences
*** Substring with Concatenation of All Words
*** Text Justification
*** Valid Number
*** Word Ladder II
** other Covered
- Longest Valid Parentheses
  [[Longest Valid Parentheses]]

* Linked List
** Easy
*** Remove Nth Node From End of List
*** Remove Duplicates from Sorted List
*** Merge Two Sorted Lists
*** Intersection of Two Linked Lists
** Medium
*** Reverse Linked List II
*** Reorder List
*** Convert Sorted List to Binary Search Tree
*** Rotate List
*** Remove Duplicates from Sorted List II
*** Sort List
*** Insertion Sort List
*** Swap Nodes in Pairs
*** Linked List Cycle
*** Linked List Cycle II
*** Add Two Numbers	
*** Partition List
** Hard	
*** Copy List with Random Pointer
*** Merge k Sorted Lists
*** Reverse Nodes in k-Group

* 树 Binary Tree, Binary Search Tree
** 二叉树的遍历

   树的遍历有两类:深度优先遍历和宽度优先遍历。深度优先遍历又可分为两种:先根(次序)遍历和后根(次序)遍历。

   树的先根遍历是:先访问树的根结点,然后依次先根遍历根的各棵子树。树的先跟遍历的结果与对应二叉树(孩子兄弟表示法)的先序遍历的结果相同。

   树的后根遍历是:先依次后根遍历树根的各棵子树,然后访问根结点。树的后跟遍历的结果与对应二叉树的中序遍历的结果相同。

   二叉树的先根遍历有: 先序遍历 (root -> left -> right), root -> right -> left; 后根遍历有: 后序遍历(left -> right -> root), right -> left -> root; 二叉树还有个一般的树没有的遍历次序, 中序遍历 (left -> root -> right)。

*** Binary Tree Preorder Traversal
    Given a binary tree, return the preorder traversal of its nodes' values.
    
    For example:

    Given binary tree {1,#,2,3},
    #+BEGIN_SRC java
    1
     \
      2
     /
    3
    #+END_SRC
    
    return [1,2,3].
    
    Note: Recursive solution is trivial, could you do it iteratively?

    用栈或Morris遍历
**** 栈： 使用栈,时间复杂度 O(n), 空间复杂度 O(n)
**** Morris先序遍历： Morris 先序遍历,时间复杂度 O(n),空间复杂度 O(1)

*** Binary Tree Inorder Traversal
    Given a binary tree, return the inorder traversal of its nodes' values.
    
    For example:

    Given binary tree {1,#,2,3},
    #+BEGIN_SRC java
   1
    \
     2
    /
   3
#+END_SRC
    
    return [1,3,2].
    
    Note: Recursive solution is trivial, could you do it iteratively?
**** 栈： 使用栈,时间复杂度 O(n), 空间复杂度 O(n)
**** Morris先序遍历： Morris 先序遍历,时间复杂度 O(n),空间复杂度 O(1)


*** Binary Tree Postorder Traversal	
    Given a binary tree, return the postorder traversal of its nodes' values.
    
    For example:

    Given binary tree {1,#,2,3},
    #+BEGIN_SRC java
   1
    \
     2
    /
   3
    #+END_SRC
    
    return [3,2,1].
    
    Note: Recursive solution is trivial, could you do it iteratively?
**** 栈： 使用栈,时间复杂度 O(n), 空间复杂度 O(n)
**** Morris先序遍历： Morris 先序遍历,时间复杂度 O(n),空间复杂度 O(1)


*** Binary Tree Level Order Traversal
    Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).
    
    For example:

    Given binary tree {3,9,20,#,#,15,7},
    #+BEGIN_SRC java
    3
   / \
  9  20
    /  \
   15   7
    #+END_SRC
    return its level order traversal as:
    #+BEGIN_SRC java
[
  [3],
  [9,20],
  [15,7]
]
    #+END_SRC
**** 递归版
**** 迭代版

*** Binary Tree Level Order Traversal II
    Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).
    
    For example:
    Given binary tree {3,9,20,#,#,15,7},
    #+BEGIN_SRC java
    3
   / \
  9  20
    /  \
   15   7
    #+END_SRC
    return its bottom-up level order traversal as:
    #+BEGIN_SRC java
[
  [15,7],
  [9,20],
  [3]
]
    #+END_SRC
**** 递归版
**** 迭代版


*** Binary Tree Zigzag Level Order Traversal	
    Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).
    
    For example:

    Given binary tree {3,9,20,#,#,15,7},
    #+BEGIN_SRC java
    3
   / \
  9  20
    /  \
   15   7
    #+END_SRC
    return its zigzag level order traversal as:
    #+BEGIN_SRC java
[
  [3],
  [20,9],
  [15,7]
]
    #+END_SRC
**** 递归版
**** 迭代版

*** Recover Binary Search Tree
    Two elements of a binary search tree (BST) are swapped by mistake.
    
    Recover the tree without changing its structure.
    
    Note:

    A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?
    
    O(n) 空间的解法是,开一个指针数组,中序遍历,将节点指针依次存放到数组里,然后寻找两处逆向的位置,先从前往后找第一个逆序的位置,然后从后往前找第二个逆序的位置,交换这两个指针的值。
    
    中序遍历一般需要用到栈,空间也是 O(n) 的,如何才能不使用栈?Morris 中序遍历。

*** Same Tree
    Given two binary trees, write a function to check if they are equal or not.
    
    Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
**** 递归版: 时间复杂度 O(n), 空间复杂度 O(logn)
**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(logn)

*** Symmetric Tree
    Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

    For example, this binary tree is symmetric:
    #+BEGIN_SRC java
    1
   / \
  2   2
 / \ / \
3  4 4  3
    #+END_SRC
    But the following is not:
    #+BEGIN_SRC java
    1
   / \
  2   2
   \   \
   3    3
    #+END_SRC
    Note:

    Bonus points if you could solve it both recursively and iteratively.
**** 递归版: 时间复杂度 O(n), 空间复杂度 O(logn)
**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(logn)


*** Balanced Binary Tree
    Given a binary tree, determine if it is height-balanced.

    For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

    时间复杂度 O(n), 空间复杂度 O(logn)

*** Flatten Binary Tree to Linked List
    Given a binary tree, flatten it to a linked list in-place.

    For example, Given
    #+BEGIN_SRC java
         1
        / \
       2   5
      / \   \
     3   4   6
    #+END_SRC
    
    The flattened tree should look like:
    #+BEGIN_SRC java
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
    #+END_SRC
    click to show hints.
    
    Hints:

    If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.
**** 递归版1: 时间复杂度 O(n), 空间复杂度 O(logn)
**** 递归版2: 时间复杂度 O(n), 空间复杂度 O(logn)
**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(logn)


*** Populating Next Right Pointers in Each Node II
    Follow up for problem "Populating Next Right Pointers in Each Node".
    
    What if the given tree could be any binary tree? Would your previous solution still work?
    
    Note:
    
    You may only use constant extra space.

    For example,

    Given the following binary tree,
    #+BEGIN_SRC java
         1
       /  \
      2    3
     / \    \
    4   5    7
    #+END_SRC
    
    After calling your function, the tree should look like:
    #+BEGIN_SRC java
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \    \
    4-> 5 -> 7 -> NULL
    #+END_SRC

    要处理一个节点,可能需要最右边的兄弟节点,首先想到用广搜。但广搜不是常数空间的,本题要求常数空间。

    注意,这题的代码原封不动,也可以解决 Populating Next Right Pointers in Each Node I.
**** 递归版: 时间复杂度 O(n), 空间复杂度 O(1)
**** 迭代版: 时间复杂度 O(n), 空间复杂度 O(1)

    
    
** 二叉树的构建
*** Construct Binary Tree from Preorder and Inorder Traversal
    Given preorder and inorder traversal of a tree, construct the binary tree.

    Note:
    
    You may assume that duplicates do not exist in the tree.
    
*** Construct Binary Tree from Inorder and Postorder Traversal
    Given inorder and postorder traversal of a tree, construct the binary tree.
    
    Note:

    You may assume that duplicates do not exist in the tree.

** 二叉树查找

*** Validate Binary Search Tree	
    Given a binary tree, determine if it is a valid binary search tree (BST).
    
    Assume a BST is defined as follows:
- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than the node's key.
- Both the left and right subtrees must also be binary search trees.
 
    时间复杂度 O(n),空间复杂度 O( log(n) )

*** Convert Sorted Array to Binary Search Tree
    Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

    二分法。
*** Convert Sorted List to Binary Search Tree
    Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

    这题与上一题类似,但是单链表不能随机访问,而自顶向下的二分法必须需要 RandomAccessIt-erator,因此前面的方法不适用本题。

    存在一种自底向上(bottom-up)的方法, 见 

    http://leetcode.com/2010/11/convert-sorted-list-to-balanced-binary.html
**** 分治法： 自项向下
**** 自底向上
** 二叉树递归
   二叉树是一个递归的数据结构,因此是一个用来考察递归思维能力的绝佳数据结构。递归一定是深搜(见“深搜与递归的区别”),由于在二叉树上,递归的味道更浓些,因此本节用“二叉树的递归”作为标题,而不是“二叉树的深搜”,尽管本节所有的算法都属于深搜。

二叉树的先序、中序、后序遍历都可以看做是 DFS,此外还有其他顺序的深度优先遍历,共有3! = 6 种。其他 3 种顺序是 root -> right -> left,right -> root -> left, right -> left -> root。
*** Minimum Depth of Binary Tree	
    Given a binary tree, find its minimum depth.

    The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
**** 递归版: 时间复杂度 O(n), 空间复杂度 O( log(n) )
**** 迭代版: 时间复杂度 O(n), 空间复杂度 O( log(n) )

*** Maximum Depth of Binary Tree	
    Given a binary tree, find its maximum depth.
    
    The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

*** Path Sum
    Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
    
    For example:
    
    Given the below binary tree and sum = 22,
    #+BEGIN_SRC java
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
    #+END_SRC

    return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

    题目只要求返回 true 或者 false,因此不需要记录路径。

    由于只需要求出一个结果,因此,当左、右任意一棵子树求到了满意结果,都可以及时 return。

    由于题目没有说节点的数据一定是正整数,必须要走到叶子节点才能判断,因此中途没法剪枝,只能进行朴素深搜。

    时间复杂度 O(n), 空间复杂度 O( log(n) )

*** Path Sum II
    Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
    
    For example:
    
    Given the below binary tree and sum = 22,
    #+BEGIN_SRC java
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
    #+END_SRC

    return
    #+BEGIN_SRC java
[
   [5,4,11,2],
   [5,8,4,5]
]
    #+END_SRC

    跟上一题相比,本题是求路径本身。且要求出所有结果,左子树求到了满意结果,不能 return, 要接着求右子树。

    时间复杂度 O(n), 空间复杂度 O( log(n) )

*** Binary Tree Maximum Path Sum	
    Given a binary tree, find the maximum path sum.
    
    The path may start and end at any node in the tree.
    
    For example:
    Given the below binary tree,
    #+BEGIN_SRC java
       1
      / \
     2   3
    #+END_SRC

    Return 6.

    这题很难,路径可以从任意节点开始,到任意节点结束。

    可以利用“最大连续子序列和”问题的思路,见第 ?????? 节。如果说 Array只有一个方向的话, 那么 Binary Tree 其实只是左、右两个方向而已,我们需要比较两个方向上的值。

    不过,Array 可以从头到尾遍历,那么 Binary Tree 怎么办呢,我们可以采用 Binary Tree 最常用的 dfs 来进行遍历。先算出左右子树的结果 L 和 R,如果 L 大于 0,那么对后续结果是有利的,我们加上 L,如果 R 大于 0,对后续结果也是有利的,继续加上 R。

    时间复杂度 O(n), 空间复杂度 O( log(n) )

*** Populating Next Right Pointers in Each Node
    Given a binary tree
    #+BEGIN_SRC java
struct TreeLinkNode {
    TreeLinkNode *left;
    TreeLinkNode *right;
    TreeLinkNode *next;
}
    #+END_SRC

    Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

    Initially, all next pointers are set to NULL.
    
    Note:
    
    You may only use constant extra space.

    You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

    For example,

    Given the following perfect binary tree,
    #+BEGIN_SRC java
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
    #+END_SRC

    After calling your function, the tree should look like:
    #+BEGIN_SRC java
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL
    #+END_SRC

    时间复杂度 O(n), 空间复杂度 O( log(n) )


*** Sum Root to Leaf Numbers
    Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
    
    An example is the root-to-leaf path 1->2->3 which represents the number 123.
    
    Find the total sum of all root-to-leaf numbers.
    
    For example,
    #+BEGIN_SRC java
    1
   / \
  2   3
    #+END_SRC

    The root-to-leaf path 1->2 represents the number 12.
    
    The root-to-leaf path 1->3 represents the number 13.
    
    Return the sum = 12 + 13 = 25.

    时间复杂度 O(n), 空间复杂度 O( log(n) )


*** Binary Tree Upside Down
    Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

    For example:

    Given a binary tree {1, 2, 3, 4, 5},
    #+BEGIN_SRC java
    1
   / \
  2   3
 / \
4   5
    #+END_SRC
    
    return the root of the binary tree [4, 5, 2, #, #, 3, 1].
    #+BEGIN_SRC java
   4
  / \
 5   2
    / \
   3   1  
    #+END_SRC

*** Binary Search Tree Iterator	
    Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
    
    Calling next() will return the next smallest number in the BST.
    
    Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

** others Covered
- Unique Binary Search Tree
  [[Unique Binary Search Tree]]
- Unique Binary Search Tree II
  [[Unique Binary Search Tree II]]

* 栈 Stack
** Easy
*** Valid Parentheses
    Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

    The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

    时间复杂度 O(n), 空间复杂度 O(n)。

** Medium
*** Evaluate Reverse Polish Notation
    Evaluate the value of an arithmetic expression in Reverse Polish Notation.
    
    Valid operators are +, -, *, /. Each operand may be an integer or another expression.
    
    Some examples:
    #+BEGIN_SRC java
  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
    #+END_SRC

*** Simplify Path
    Given an absolute path for a file (Unix-style), simplify it.
    
    For example,
    #+BEGIN_SRC java
    path = "/home/", => "/home"
    path = "/a/./b/../../c/", => "/c"
    #+END_SRC
    
    click to show corner cases.
    
    Corner Cases:
    #+BEGIN_SRC java
    Did you consider the case where path = "/../"?
    In this case, you should return "/".
    Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
    In this case, you should ignore redundant slashes and return "/home/foo".
    #+END_SRC

** Hard
*** Longest Valid Parentheses
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

For "(()", the longest valid parentheses substring is "()", which has length = 2.

Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.
**** 使用栈: 时间复杂度 O(n), 空间复杂度 O(n)

这个问题有点不一样的地方是，输入很可能不合理，也就是括号很可能不匹配，这怎么做？我的做法是用一个数组来做标记，依然是左括号入栈（入栈的是他的位置）。右括号出栈，当一对括号成功匹配的时候，把标记数组中他们相对应的位置标记为1。这样过一遍之后，扫描一下整个标记数组，有多少个连续的1，就是有多少个连续的匹配，输出一下个数就行了。
#+BEGIN_SRC java
public int longestValidParentheses(String s) {
    Stack<Integer> k = new Stack<Integer>();
    int [] res = new int[s.length()];
    char j;
    int tmp = 0;
    for (int i = 0; i < s.length(); i++) {
        j = s.charAt(i);
        if (j == '(') 
            k.push(i);
        else if (j == ')'){
            if (!k.isEmpty()) {
                res[i] = 1;
                tmp = k.pop();
                res[tmp] = 1;
            }
        }
    }
    int max = 0;
    int i = 0;
    while (i < s.length()) {
        tmp = 0;  // reset value
        while (i < s.length() && res[i] == 0) i++;
        while (i < s.length() && res[i] == 1) {
            tmp++;
            i++;
        }
        max = Math.max(max, tmp);
    }
    return max;
}
#+END_SRC

不用数组的思路： 

在处理括号匹配问题上，我们一般使用栈来解决。这一题也可以。

顺序扫描字符串：

初始化：在栈中压入-1

一、若碰到'('，则把当前位置压入栈中

二、若碰到')'：

     (1)、如果栈顶元素不是'('，则把当前位置压入栈中；

     (2)、如果栈顶元素时'('：栈顶元素出栈，当前的合法子串长度 = 当前字符索引 - 新的栈顶元素；更新最大子串长度
#+BEGIN_SRC java
public int longestValidParentheses(String s) {
    Stack<Integer> k = new Stack<Integer>();
    int res = 0;
    k.push(-1);    // 为了处理边界条件，在栈底添加 -1
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(')
            k.push(i);
        else { // ')'
            if (k.isEmpty())
                k.push(i);
            else {
                int tmp = k.peek();
                if (tmp >= 0 && s.charAt(tmp) == '(') { // -1
                    k.pop();
                    res = Math.max(res, i - k.peek());
                } else k.push(i);
            }
        }
    }
    return res;
}
#+END_SRC
**** 动态规划： 

这种括号匹配的问题一般使用动态规划进行解决。使用 dp[i] 表示从位置 i 开始的最长合法括号序列的长度。

考虑第 i 个位置的括号：
- 如果是右括号，则 dp[i] = 0， 因为第一个是右括号是没有合法匹配
- 如果是左括号，则考虑下一个位置 i+1 的情况，事实上，这是dp[i+1]的问题，可以以同样方法解决。之后可以知道第i位该匹配的位置为 i + dp[i+1] + 1 的位置，直接判断其是否匹配即可。
注意做括号匹配到其对应的右括号时，后面可能还有左括号以继续匹配。
#+BEGIN_SRC java
public int longestValidParentheses(String s) {
    int n = s.length();
    int res = 0;
    int [] dp = new int[n]; // dp[i]表示从i开始的最长合法括号序列
    int j = 0;
    for (int i = n - 2; i >= 0; i--) {
        if (s.charAt(i) == '(') {  // 第一个括号必须为左括号
            j = dp[i + 1] + i + 1; // 匹配该左括号的位置
            if (j < n && s.charAt(j) == ')') { // 满足匹配
                dp[i] = dp[i + 1] + 2;
                if (j + 1 < n)
                    dp[i] += dp[j + 1]; // 后面可能还有
                res = Math.max(res, dp[i]);
            }
        }
    }
    return res;
}
#+END_SRC

*** Trapping Rain Water
    Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

    For example, 

    Given [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], return 6.
    
    #+CAPTION: Trapping Rain Water
    [[./pic/rainwatertrap.png]]
    
    The above elevation map is represented by array [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
    
    *Tags:* Array, Stack, Two Pointers

    对于每个柱 子,找到其左右两边最 高的柱子, 该柱子能容纳的面积就是 min(max_left, max_right) - height。所以,
    
1. 从左往右扫描一遍,对于每个柱子,求取左边最大值;
2. 从右往左扫描一遍,对于每个柱子,求最大右值;
3. 再扫描一遍,把每个柱子的面积并累加。
也可以,
1. 扫描一遍,找到最高的柱子,这个柱子将数组分为两半;
2. 处理左边一半;
3. 处理右边一半。
**** 思路 1, 时间复杂度 O(n), 空间复杂度 O(n)
**** 思路 2, 时间复杂度 O(n), 空间复杂度 O(1)
**** 思路 3, 时间复杂度 O(n), 空间复杂度 O(n)
**** 
*** Largest Rectangle in Histogram
    Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
    
    #+CAPTION: Largest Rectangle in Histogram 1
    [[./pic/rectangle1.png]]

    Above is a histogram where width of each bar is 1, given height = [2, 1, 5, 6, 2, 3].

    #+CAPTION: Largest Rectangle in Histogram 2
    [[./pic/rectangle2.png]]
    
    The largest rectangle is shown in the shaded area, which has area = 10 unit.
    
    For example,

    Given height = [2, 1, 5, 6, 2, 3],

    return 10.

    简单的, 类似于 Container With Most Water(), 对每个柱子, 左右扩展, 直到碰到比自己矮的, 计算这个矩形的面积, 用一个变量记录最大的面积, 复杂度 O(n^2 ), 会超时。

    如图所示, 从左到右处理直方, 当 i = 4 时, 小于当前栈顶(即直方 3),  对于直方 3, 无论后面还是前面的直方, 都不可能得到比目前栈顶元素更高的高度了, 处理掉直方 3(计算从直方 3到直方 4 之间的矩形的面积, 然后从栈里弹出); 对于直方 2 也是如此; 直到碰到比直方 4 更矮的直方 1。

    这就意味着, 可以维护一个递增的栈, 每次比较栈顶与当前元素。如果当前元素小于栈顶元素, 则入栈, 否则合并现有栈, 直至栈顶元素小于当前元素。结尾时入栈元素 0, 重复合并一次。
**** O (n^2)

最暴力的方法就是枚举所有区间的最大矩形值，然后选择最大的。可以通过分别枚举区间右边界和区间左边界，时间复杂度O(n^2)这样做大数据会超时。

枚举的过程中可以优化一下： 如果 height[i+1] > height[i], 那么区间 [k...i] 内的最大矩形肯定不会超过区间 [k...i+1] 内的最大矩形， 比如上例中的区间 [0...3] 内的矩形要大于 [0...2] 内的矩形， 因为 height[3] > height[2]。因此我们在枚举区间右边界时，只选择那些 height 上升区间的最大值处作为右边界（比如例子中的2 、6 、3）。优化后可以通过leetcode的大数据，虽然做了优化，但是时间复杂度还是O(n^2)。

#+BEGIN_SRC java
public int largestRectangleArea(int[] height) {
    int n = height.length;
    int res = 0;
    int right = 0;
    int local = 0;
    int minVal = 0;
    while (right < n) {
        if (right + 1 < n && height[right + 1] >= height[right])
            right++;
        else { // found right border
            minVal = height[right];
            for (int left = right; left >= 0; left--) {
                minVal = Math.min(minVal, height[left]);
                local = minVal * (right - left + 1);
                res = Math.max(res, local);
            }
            right++;
            local = 0;
            minVal = 0;
        }
    }
    return res;
}
#+END_SRC

**** 栈： 时间复杂度 O(n), 空间复杂度 O(n)。

主要思路：

我们知道，每个木板将对应多个包含自身的直方图面积，我们从中选取最大的一个面积。

以上题为例，height[ 1 ]对应的包含自身直方图面积集合为 {1, 2, 3, 4, 5, 6 } ，我们只需要知道最大的面积 6 即可，其它的面积就不用考虑。

我们就比较所有height[i] 对应最大直方图面积，把整体最大的直方图面积记为maxArea。

分析到这，我们很明显的可以知道时间复杂度为 O(n)。

现在关键问题就变为如何得到 height[i] 对应的最大直方图面积。

这里用一个栈s来保存之前的元素索引。

s为空时，直接让 i 栈；

- 当height[i]<height[s.top()]时，说明height[s.top()]对应的直方图面积不会再增加了，此时达到最大，可以出栈了；

- 当height[i]>=height[s.top()]时，说明height[s.top()]对应的直方图面积还是有潜力增加的哈，此时，i 入栈，++i 。

以上取 i 从 0 到 n-1 。

当 i 达到n 时，而 栈不为空，说明还有部分height中元素对应的最大直方图面积没有求出来……

于是，当栈不为空时，求 height[s.top()]对应最大直方图面积。

#+BEGIN_SRC java
public int largestRectangleArea(int[] height) {
    Stack<Integer> s = new Stack<Integer>();
    int [] hnew = new int[height.length + 1];// 数组末尾插入dummy元素0
    hnew = Arrays.copyOf(height, height.length + 1);
    int res = 0; 
    int tmp;     
    int left;
    for (int i = 0; i <= height.length; i++) {
        if (s.isEmpty() || hnew[i] > hnew[s.peek()])
            s.push(i); // 栈内保存的是数组 height 的下标索引
        else {
            tmp = s.pop();
            res = Math.max(res, hnew[tmp] * 
                           (s.isEmpty() ? i : i - s.peek() - 1));
            i--;
        }
    }
    return res;
}
#+END_SRC

这题应该还有很多很巧妙的解法，念天脑袋不太转，暂时留在这里吧，改天再回来修改~~

http://www.cnblogs.com/felixfang/p/3676193.html

*** Maximal Rectangle
    Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.

    *Tags:* Array Hash Table Stack Dynamic Programming
**** 栈： O(n)    
这是一道非常综合的题目，要求在0-1矩阵中找出面积最大的全1矩阵。刚看到这道题会比较无从下手，brute force就是对于每个矩阵都看一下，总共有m(m+1)/2*n(n+1)/2个子矩阵（原理跟字符串子串类似，字符串的子串数有n(n+1)/2，只是这里是二维情形，所以是两个相乘），复杂度相当高，肯定不是面试官想要的答案，就不继续想下去了。

这道题的解法灵感来自于Largest Rectangle in Histogram这道题，假设我们把矩阵沿着某一行切下来，然后把切的行作为底面，将自底面往上的矩阵看成一个直方图（histogram）。直方图的中每个项的高度就是从底面行开始往上1的数量。根据Largest Rectangle in Histogram我们就可以求出当前行作为矩阵下边缘的一个最大矩阵。接下来如果对每一行都做一次Largest Rectangle in Histogram，从其中选出最大的矩阵，那么它就是整个矩阵中面积最大的子矩阵。
算法的基本思路已经出来了，剩下的就是一些节省时间空间的问题了。

我们如何计算某一行为底面时直方图的高度呢？ 如果重新计算，那么每次需要的计算数量就是当前行数乘以列数。然而在这里我们会发现一些动态规划的踪迹，如果我们知道上一行直方图的高度，我们只需要看新加进来的行（底面）上对应的列元素是不是0，如果是，则高度是0，否则则是上一行直方图的高度加1。利用历史信息，我们就可以在线行时间内完成对高度的更新。我们知道，Largest Rectangle in Histogram的算法复杂度是O(n)。所以完成对一行为底边的矩阵求解复杂度是O(n+n)=O(n)。接下来对每一行都做一次，那么算法总时间复杂度是O(m*n)。

空间上，我们只需要保存上一行直方图的高度O(n)，加上Largest Rectangle in Histogram中所使用的空间O(n)，所以总空间复杂度还是O(n)。

#+BEGIN_SRC java
private int largestRectangleArea(int[] height) {
    Stack<Integer> s = new Stack<Integer>();
    int [] hnew = new int[height.length + 1];
    hnew = Arrays.copyOf(height, height.length + 1);
    int res = 0; 
    int tmp;     
    int left;
    for (int i = 0; i <= height.length; i++) {
        if (s.isEmpty() || hnew[i] > hnew[s.peek()]) s.push(i);
        else {
            tmp = s.pop();
            res = Math.max(res, hnew[tmp] * 
                           (s.isEmpty() ? i : i - s.peek() - 1));
            i--;
        }
    }
    return res;
}

public int maximalRectangle(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;
    int [] h = new int[matrix[0].length];
    int res = 0;     // record max area
    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) 
            h[j] = matrix[i][j] == '0' ? 0 : h[j] + 1;
        res = Math.max(res, largestRectangleArea(h));
    }
    return res;
}
#+END_SRC
**** 动态规划：

一般一个题目我首先会想想怎么暴力解决，比如这一题，可以枚举出所有的矩形，求出其中的面积最大者，那么怎么枚举呢，如果分别枚举矩形的宽度和高度，这样还得枚举矩形的位置，复杂度至少为O(n^4) (计算复杂度是我们把matrix的行、列长度都泛化为n，下同)，我们可以枚举矩形左上角的位置，那么知道了矩形左上角的位置，怎么计算以某一点为左上角的矩形的最大面积呢？举例如下，下面的矩阵我们以(0,0)为矩形的左上角：
#+BEGIN_SRC java
1 1 1 1 0 0
1 1 1 0 1 1
1 0 1 0 1 1
0 1 1 1 1 1
1 1 1 1 1 1
#+END_SRC

矩形高度是1时,宽度为第一行中从第一个位置起连续的1的个数,为4,面积为4 * 1=4

矩形高度是2时,第二行从第一个位置起连续1的个数是3,宽度为min(3,4)=3,面积为3*2=6

矩形高度为3时,第三行从第一个位置起连续1的个数是1,宽度为min(1,3)=1,面积为1*3=3

矩形高度为4时,第四行从第一个位置起连续1的个数是0,宽度为min(0,1)=0,面积为0*4=0

后面的行就不用计算了,因为上一行计算的宽度是0,下面所有宽度都是0

因此以(0,0)为左上角的矩形的最大面积是6，计算以某一点为左上角的矩形的最大面积复杂度是O(n)。

注意到上面我们用到了信息“从某一行某个位置开始连续的1的个数”，这个我们可以通过动态规划求得：设dp[i][j]是从点(i,j)开始，这一行连续1的个数，动态规划方程如下：

初始条件：
- dp[i][n-1] = (matrix[i][n-1] == '1') （n是matrix的列数）
- dp[i][j] = (matrix[i][j] == '1') ?  1 + dp[i][j + 1] : 0 (从方程看出我们应该从每一行的后往前计算)
计算dp复杂度O(n^2)，枚举左上角位置以及计算以该位置为左上角的矩形最大面积复杂度是O(n^2*n)=O(n^3)，总的复杂度是O(n^3)

这个算法还可以优化，枚举到某个点时我们可以假设该点右下方全是1，得到一个假设最大面积，如果这个面积比当前计算好的面积还要小，该点就可以直接跳过；在上面计算以某点为左上角的矩形面积时，也可以剪枝，剪枝方法同上。《JustDoIT》
#+BEGIN_SRC java
public int maximalRectangle(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;
    int m = matrix.length;
    int n = matrix[0].length;
    int [][] dp = new int[m][n];
    int res = 0;
    int width = 0;
    for (int i = 0; i < m; i++) 
        dp[i][n - 1] = matrix[i][n - 1] == '1' ? 1 : 0;
    for (int i = 0; i < m; i++) 
        for (int j = n - 2; j >= 0; j--) 
            if (matrix[i][j] == '1')
                dp[i][j] = dp[i][j + 1] + 1;
    for (int i = 0; i < m; i++) // 以每个点作为矩形的左上角计算所得的最大矩形面积
        for (int j = 0; j < n; j++) {
            if ((n - j) * (m - i) <= res)
                break;          // 剪枝，column-j 是最大宽度，row-i 是最大高度
            width = dp[i][j];
            for (int k = i; k < m && width > 0; k++) {
                if (width * (m - i) <= res)
                    break;     // 剪枝,row-i 是以点(i,j) 为左上角的矩形的最大高度
                if (width > dp[k][j])
                    width = dp[k][j]; // 矩形宽度要取从第i 行到第k 行宽度的最小值
                res = Math.max(res, width * (k - i + 1));
            }
        }
    return res;
}
#+END_SRC

** Heap
*** Merge k sorted List
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

*Tags*: Divide and Conquer, Linked List, Heap
#+BEGIN_SRC java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;
    ListNode result;
    if (l1.val < l2.val) {
        result = l1;
        l1 = l1.next;
        result.next = null;
    } else {
        result = l2;
        l2 = l2.next;
        result.next = null;
    }
    ListNode curr = result;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            curr.next = l1;
            curr = curr.next;
            l1 = l1.next;
            curr.next = null;
        } else {
            curr.next = l2;
            curr = curr.next;
            l2 = l2.next;
            curr.next = null;
        }
    }
    if (l1 == null && l2 == null)
        return result;
    l1 = (l1 == null) ? l2 : l1;
    curr.next = l1;
    return result;
}
        
public ListNode mergeKLists(List<ListNode> lists) {
    if (lists.size() == 0) return null;
    if (lists.size() == 1) return lists.get(0);
    if (lists.size() == 2) return mergeTwoLists(lists.get(0), lists.get(1));
    return mergeTwoLists((mergeKLists(lists.subList(0, lists.size() / 2))),
                         (mergeKLists(lists.subList(lists.size() / 2, lists.size()))));
}
#+END_SRC

** others Covered
- Binary Tree Preorder Traversal
  [[Binary Tree Preorder Traversal]]
- Binary Tree Inorder Traversal
  [[Binary Tree Inorder Traversal]]
- Binary Tree Postorder Traversal
  [[Binary Tree Postorder Traversal]]
- Binary Search Tree Iterator	
  [[Binary Search Tree Iterator	]]
- Binary Tree Zigzag Level Order Traversal
  [[Binary Tree Zigzag Level Order Traversal]]
- Min Stack
  [[Min Stack]]

* Hash Table
** Easy
*** Valid Sudoku
*** Two Sum III
** Medium
*** Two Sum
*** 4Sum
*** Binary Tree Inorder Traversal
*** Fraction to Recurring Decimal
*** Single Number
*** Anagrams
*** Longest Substring Without Repeating Characters	
** Hard	
*** Minimum Window Substring
*** Copy List with Random Pointer
*** Sudoku Solver
*** Max Points on a Line
*** Substring with Concatenation of All Words
*** Longest Substring with At Most Two Distinct Characters
** other Covered
- Maximal Rectangle
  [[Maximal Rectangle]]

* 广度优先搜索 Breadth First Search
** Easy
*** Binary Tree Level Order Traversal
*** Binary Tree Level Order Traversal II
** Medium
*** Word Ladder
Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:
- Only one letter can be changed at a time
- Each intermediate word must exist in the dictionary
For example,

Given:
#+BEGIN_SRC java
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
#+END_SRC
Note:
- Return 0 if there is no such transformation sequence.
- All words have the same length.
- All words contain only lowercase alphabetic characters.
*** Surrounded Regions
*** Clone Graph	
*** Binary Tree Zigzag Level Order Traversal
*** Minimum Depth of Binary Tree
    
** Hard
*** Word Ladder II

* 深度优先搜索 Depth First Search
** Easy
*** Path Sum
*** Balanced Binary Tree
*** Same Tree
*** Symmetric Tree
*** Maximum Depth of Binary Tree
** Medium
*** Sum Root to Leaf Numbers	
*** Convert Sorted List to Binary Search Tree
*** Convert Sorted Array to Binary Search Tree
*** Construct Binary Tree from Preorder and Inorder Traversal
*** Construct Binary Tree from Inorder and Postorder Traversal
*** Clone Graph
*** Flatten Binary Tree to Linked List
*** Populating Next Right Pointers in Each Node
*** Validate Binary Search Tree
*** Path Sum II
** Hard
*** Recover Binary Search Tree
*** Populating Next Right Pointers in Each Node II
*** Binary Tree Maximum Path Sum
* 排序
** Medium
*** Sort Colors
*** Sort List
*** Largest Number
** Hard
*** Insertion Sort List
*** Maximum Gap
*** Merge Intervals	
*** Insert Interval

* 查找 Binary Search
** Medium
*** Sqrt(x)
*** Divide Two Integers
*** Search in Rotated Sorted Array II
*** Two Sum II - Input array is sorted
*** Pow(x, n)
*** Search for a Range
*** Search a 2D Matrix
*** Find Minimum in Rotated Sorted Array
*** Search Insert Position	
*** Find Peak Element
** Hard
*** Median of Two Sorted Arrays
*** Dungeon Game
*** Find Minimum in Rotated Sorted Array II
*** Search in Rotated Sorted Array
* 暴力枚举法
** 
*** 
* 分治法 Divide and Conqure
** Easy
*** Majority Element
    Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
    
    You may assume that the array is non-empty and the majority element always exist in the array.
    
    Credits:
    
    Special thanks to @ts for adding this problem and creating all test cases.
    
    *Tags:* Divide and Conquer, Array, Bit Manipulation

** Medium
*** Maximum Subarray
    Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
    
    For example, given the array [-2, 1, -3, 4, -1, 2, 1, -5, 4], 
    
    the contiguous subarray [4, -1, 2, 1] has the largest sum = 6.
    
    click to show more practice.
    
    *More practice:*

    If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
    
    *Tags:* Divide and Conquer, Array, Dynamic Programming

** Hard
*** Merge K sorted List
    Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

    *Tags:* Divide and Conquer Linked, List, Heap

*** Median of Two Sorted Array
    There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

    *Tags:* Divide and Conquer, Array, Binary Search

* 贫心法 Greedy Search
** Medium
*** Gas Station
    There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

    You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

    Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.
    
    Note:
    
    The solution is guaranteed to be unique.

*** Best Time to Buy and Sell Stock
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

贪心法, 分别找到价格最低和最高的一天, 低进高出, 注意最低的一天要在最高的一天之前。把原始价格序列变成差分序列, 本题也可以做是最大 m 子段和, m = 1。

时间复杂度 O(n), 空间复杂度 O(1).

#+BEGIN_SRC java
public int maxProfit(int[] prices) {
    int lowest = Integer.MAX_VALUE;
    int maxProfit = 0;
    for (int i = 0; i < prices.length; i++) {
        if (prices[i] < lowest) lowest = prices[i];
        else maxProfit = Math.max(maxProfit, prices[i] - lowest);
    }
    return maxProfit;
}
#+END_SRC

*** Best Time to Buy and Sell Stock II
    Say you have an array for which the ith element is the price of a given stock on day i.

    Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

贪心法, 低进高出, 把所有正的价格差价相加起来。把原始价格序列变成差分序列, 本题也可以做是最大 m 子段和, m = 数组长度。

#+BEGIN_SRC java
public int maxProfit(int[] prices) {
    int result = 0;
    for (int i = 0; i < prices.length-1; i++) 
        result += (prices[i] < prices[i+1]) ? prices[i+1]-prices[i] : 0;
    return result;
}
#+END_SRC

*** Jump Game
    Given an array of non-negative integers, you are initially positioned at the first index of the array.

    Each element in the array represents your maximum jump length at that position.

    Determine if you are able to reach the last index.
    
    For example:
    
    A = [2, 3, 1, 1, 4], return true.
    
    A = [3, 2, 1, 0, 4], return false.

** Hard
*** Jump Game II
    Given an array of non-negative integers, you are initially positioned at the first index of the array.
    
    Each element in the array represents your maximum jump length at that position.
    
    Your goal is to reach the last index in the minimum number of jumps.
    
    For example:
    
    Given array A = [2,3,1,1,4]
    
    The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)
*** Candy
    There are N children standing in a line. Each child is assigned a rating value.
    
    You are giving candies to these children subjected to the following requirements:
    
    Each child must have at least one candy.
    
    Children with a higher rating get more candies than their neighbors.

    What is the minimum candies you must give?
*** Wildcard Matching
    Implement wildcard pattern matching with support for '?' and '*'.
    #+BEGIN_SRC java
    '?' Matches any single character.
    '*' Matches any sequence of characters (including the empty sequence).
    #+END_SRC    
    
    The matching should cover the entire input string (not partial).
    
    The function prototype should be:
    
    bool isMatch(const char *s, const char *p)
    
    Some examples:
    #+BEGIN_SRC java
    isMatch("aa","a") → false
    isMatch("aa","aa") → true
    isMatch("aaa","aa") → false
    isMatch("aa", "*") → true
    isMatch("aa", "a*") → true
    isMatch("ab", "?*") → true
    isMatch("aab", "c*a*b") → false
    #+END_SRC
    *Tags:* Dynamic Programming, Backtracking, Greedy, String

* 动态归划 Dynamic Programming
** Easy
*** Climbing Stairs
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways
can you climb to the top?
**** O(n)
#+BEGIN_SRC java
public int climbStairs(int n) {
    int [] res = new int[n + 1];
    res[0] = 1; // 1 stair
    res[1] = 2; // 2 stair
    for (int i = 2; i < n; i++) 
        res[i] = res[i - 2] + res[i - 1];
    return res[n - 1];
}
#+END_SRC

Considering odd and even, 实现滚动数组
#+BEGIN_SRC java
public int climbStairs(int n) {
    if(n <= 0) return 0;
    int [] stairs = {1, 2};
    for(int i = 2;i < n; i++)
        stairs[i % 2] = stairs[0] + stairs[1];
    return n % 2 == 0 ? stairs[1] : stairs[0];
}
#+END_SRC
**** O( log(n) )

     https://oj.leetcode.com/discuss/11211/o-log-n-solution-with-matrix-multiplication

     Most solutions are DP with runtime O(n) and O(1) space, the only O(log(n)) solution so far is lucastan's using Binet's formula.
     
     There actually is a matrix multiplication solution which also runs in O(log(n)). It basically calculates fibonacci numbers by power of matrix ((0, 1), (1, 1)) ^ (n-1).

#+BEGIN_SRC java
private int[][] pow(int[][] a, int n) {
    int[][] ret = {{1, 0}, {0, 1}};
    while (n > 0) {
        if ((n & 1) == 1) 
            ret = multiply(ret, a);
        n >>= 1;
        a = multiply(a, a);
    }
    return ret;
}

private int[][] multiply(int[][] a, int[][] b) {
    int[][] c = new int[2][2];
    for (int i = 0; i < 2; i++) 
        for (int j = 0; j < 2; j++) 
            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
    return c;
}

public int climbStairs(int n) {
    int[][] a = {{0, 1}, {1, 1}};
    int[][] m = pow(a, n - 1);
    return m[0][1] + m[1][1];
}
#+END_SRC
** Medium
*** Unique Path
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
#+caption: Unique Path
[[./pic/uniquePaths.png]]

Above is a 3 x 7 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

这里Note的含义是: 如果数值过大会溢出的。--《靖空间》

方法论总结：遇上新颖没见过的题目：
- 查看其特征；
- 搜索大脑有什么熟悉的题目，可以套的，或者相似的可以退到出来的； 
- 罗列出来这些题目：全排列， 水槽，TwoSum，等等；
- 搜索大脑里面有什么熟悉的算法；
- 罗列出来：动态规划法，递归，回溯，二叉树遍历，贪心法，递归树，分治法，观察特征计算法，等等，肯定有可以套的算法的！ 
- 最后选定算法解题； 
- 没有优化的算法，可以使用暴力法，先解决再说！

最后实在没招了，想办法让人提示，主要是提示用什么算法，能给个思路更好了，O(∩_∩)O~

**** 深搜， 递归法

     深搜,小集合可以过,大集合会超时；时间复杂度 O(n^4),空间复杂度 O(n)；
#+BEGIN_SRC java
public int uniquePaths(int m, int n) {
    if (m < 1 || n < 1) return 0;   // 终止条件
    if (m == 1 && n == 1) return 1; // 收敛条件
    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);
}  
#+END_SRC
**** 备忘录法: 时间复杂度 O(n^2), 空间复杂度 O(n^2)

     给前面的深搜,加个缓存,就可以过大集合了。即备忘录法。
#+BEGIN_SRC java
// 深搜 + 缓存,即备忘录法
// 时间复杂度 O(n^2), 空间复杂度 O(n^2)
class Solution {
    private int [][] f;    // 缓存
        
    public int dfs(int x, int y) {
        if (x < 1 || y < 1) return 0;   // 数据非法,终止条件
        if (x == 1 && y == 1) return 1; // 回到起点,收敛条件
        return getOrUpdate(x - 1, y) + getOrUpdate(x, y - 1);
    }
    
    public int getOrUpdate(int x, int y) {
        if (f[x][y] > 0) return f[x][y];
        else return f[x][y] = dfs(x, y);
    }
    
    public int uniquePaths(int m, int n) {        
        // 0 行和 0 列未使用
        f = new int[m + 1][n + 1]; // 缓存
        return dfs(m, n);
    }
}
#+END_SRC
**** 动态规划

     算法1的递归解法中，其实我们计算了很多重复的子问题，比如计算uniquePaths(4, 5) 和 uniquePaths(5, 3)时都要计算子问题uniquePaths(3,2)，再者由于uniquePaths(m, n) = uniquePaths(n, m)，这也使得许多子问题被重复计算了。

     要保存子问题的状态，这样很自然的就想到了动态规划方法，设dp[i][j] = uniquePaths(i, j)， 那么动态规划方程为：

     动态方程: dp[i][j] = dp[i-1][j] + dp[i][j-1]

     边界条件：dp[i][ 1 ] = 1, dp[ 1 ][j] = 1
#+BEGIN_SRC java
public int uniquePaths(int m, int n) {
    if (m == 0 || n == 0) return 1;
    else if (m == 1 && n == 1) return 1;
            
    int [][] dp = new int[m][n];
    for (int i = 0; i < n; i++) 
        dp[0][i] = 1;
    for (int i = 0; i < m; i++)
        dp[i][0] = 1;
    dp[0][0] = 0;
    for (int i = 1; i < m; i++) 
        for (int j = 1; j < n; j++) 
            dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
    return dp[m-1][n-1];
}
#+END_SRC

滚动数组
#+BEGIN_SRC java
// 动规,滚动数组
// 时间复杂度 O(n^2), 空间复杂度 O(n)
int uniquePaths(int m, int n) {
    vector<int> f(n, 0);
    f[0] = 1;
    for (int i = 0; i < m; i++) {
        for (int j = 1; j < n; j++) {
            // 左边的 f[j], 表示更新后的 f[j], 与公式中的 f[i[[j] 对应
            // 右边的 f[j], 表示老的 f[j], 与公式中的 f[i-1][j] 对应
            f[j] = f[j - 1] + f[j];
        }
    }
    return f[n - 1];
}
#+END_SRC

**** 组合数 （ C_{m+n-2}^{m-1} ）

     一个 m 行, n 列的矩阵, 机器人从左上走到右下总共需要的步数是 m + n - 2, 其中向下走的步数是 m - 1, 因此问题变成了在 m + n - 2 个操作中, 选择 m–1 个时间点向下走, 选择方式有多少种。即C_{m+n-2}^{m-1}。这里需要注意的是求组合数时防止乘法溢出。
#+BEGIN_SRC java
public int combination(int a, int b) {
    if (b > (a >>> 1)) b = a - b;
    long res = 1;
    for (int i = 1; i <= b ; i++) 
        res = res * (a - i + 1) / i;
    return (int)res;
}
        
public int uniquePaths(int m, int n) {
    return combination(m + n - 2, m - 1);
}
#+END_SRC

*** Unique Path with Obstacles
Follow up for "Unique Paths":

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.
#+BEGIN_SRC java
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
#+END_SRC

The total number of unique paths is 2.

Note: m and n will be at most 100.
**** 备忘录法
#+BEGIN_SRC java
// LeetCode, Unique Paths II
// 深搜 + 缓存, 即备忘录法
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {
        const int m = obstacleGrid.size();
        const int n = obstacleGrid[0].size();
        // 0 行和 0 列未使用
        this->f = vector<vector<int> >(m + 1, vector<int>(n + 1, 0));
        return dfs(obstacleGrid, m, n);
    }

private:
    vector<vector<int> > f;                    // 缓存
    int dfs(const vector<vector<int> > &obstacleGrid,
            int x, int y) {
        if (x < 1 || y < 1) return 0;         // 数据非法,终止条件
        
        if (obstacleGrid[x-1][y-1]) return 0; // (x,y) 是障碍
        if (x == 1 and y == 1) return 1;      // 回到起点,收敛条件
        return getOrUpdate(obstacleGrid, x - 1, y) +
                getOrUpdate(obstacleGrid, x, y - 1);
    }
    int getOrUpdate(const vector<vector<int> > &obstacleGrid,
                    int x, int y) {
        if (f[x][y] > 0) return f[x][y];
        else return f[x][y] = dfs(obstacleGrid, x, y);
    }
};
#+END_SRC
**** 动态规划

     与上一题类似, 但要特别注意第一列的障碍。在上一题中,第一列全部是1, 但是在这一题中不同,第一列如果某一行有障碍物,那么后面的行应该为 0。
#+BEGIN_SRC java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    if (m == 0 || n == 0) return 0;
    else if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return 0;
    else if (m == 1 || n == 1) return obstacleGrid[m-1][n-1] == 1 ? 0 : 1;
            
    int [][] arr = new int[m][n];
    for (int i = 0; i < n; i++)
        if (obstacleGrid[0][i] == 1) {
            for (int j = i; j < n; j++) 
                arr[0][j] = 0;
            i = n;
        } else arr[0][i] = 1;

    for (int i = 0; i < m; i++)
        if (obstacleGrid[i][0] != 1)
            arr[i][0] = 1;
        else 
            for (int j = i; j < m; j++) {
                arr[j][0] = 0;
                i = m;
            }
            
    arr[0][0] = 0;
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (obstacleGrid[i][j] == 1)
                arr[i][j] = 0;
            else 
                arr[i][j] = arr[i][j - 1] + arr[i - 1][j];
        }
    }
    return arr[m-1][n-1];
}
#+END_SRC
*** Minimum Path Sum
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

跟 Unique Paths (见 §10.2) 很类似。设状态为 f[i][j], 表示从起点 (0, 0) 到达 (i, j) 的最小路径和, 则状态转移方程为: 

转移方程: f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i][j]
**** 备忘录法

     代码应该可以再优化一下。
#+BEGIN_SRC java
private int [][] f;

private int getOrUpdate(int [][] grid, int x, int y) {
    if (x < 0 || y < 0) return Integer.MAX_VALUE;
    if (f[x][y] >= 0) return f[x][y];
    else {
        f[x][y] = dfs(grid, x, y);
        return f[x][y];
    }
}
        
private int dfs(int [][] grid, int x, int y) {
    if (x < 0 || y < 0) return Integer.MAX_VALUE;
    if (x == 0 && y == 0) return grid[0][0];
    return Math.min(getOrUpdate(grid, x - 1, y),
                    getOrUpdate(grid, x, y - 1)) + grid[x][y];
}

public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    f = new int[m][n];
    for (int i = 0; i < m; i++) 
        for (int j = 0; j < n; j++) 
            f[i][j] = -1;
    return dfs(grid, m - 1, n - 1);
}
#+END_SRC
**** 动态规划
#+BEGIN_SRC java
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    if (m == 0 || n == 0) return 0;
            
    int [][] f = new int[m][n];
    f[0][0] = grid[0][0];
    for (int i = 1; i < n; i++)
        f[0][i] = f[0][i - 1] + grid[0][i];
    for (int i = 1; i < m; i++)
        f[i][0] = f[i - 1][0] + grid[i][0];
            
    for (int i = 1; i < m; i++) 
        for (int j = 1; j < n; j++) 
            f[i][j] = Math.min(f[i][j - 1], f[i - 1][j]) + grid[i][j];
    return f[m-1][n-1];
}
#+END_SRC
**** 动态规划 + 滚动数组
*** Unique Binary Search Tree
    Given n, how many structurally unique BST's (binary search trees) that store values 1...n?
    
    For example, Given n = 3, there are a total of 5 unique BST's.
    #+BEGIN_SRC java
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
    #+END_SRC

    如果把上例的顺序改一下,就可以看出规律了。《水中的鱼》
    #+BEGIN_SRC java
    1           1                   2                    3           3
     \           \                 / \                 /            / 
      3           2               1   3               2            1
     /             \                                 /              \
    2               3                               1                2
    #+END_SRC

    比如，以1为根的树有几个，完全取决于有二个元素的子树有几种。同理，2为根的子树取决于一个元素的子树有几个。以3为根的情况，则与1相同。
    
    定义Count[i] 为以[0,i]能产生的Unique Binary Tree的数目，
    
    如果数组为空，毫无疑问，只有一种BST，即空树， Count[ 0 ] =1
    
    如果数组仅有一个元素{1}，只有一种BST，单个节点, Count[ 1 ] = 1
    
    如果数组有两个元素{1,2}， 那么有如下两种可能
    #+BEGIN_SRC java
    1                2
     \              /
      2            1
    Count[2] = Count[0] * Count[1]   ( 1 为根的情况 )
             + Count[1] * Count[0]   ( 2 为根的情况 )
    #+END_SRC

   再看一遍三个元素的数组，可以发现BST的取值方式如下：
   #+BEGIN_SRC java
   Count[3] = Count[0]*Count[2]  ( 1 为根的情况 )
            + Count[1]*Count[1]  ( 2 为根的情况 )
            + Count[2]*Count[0]  ( 3 为根的情况 )
   #+END_SRC

   所以，由此观察，当数组为 1, 2, 3, ..., n 时,基于以下原则的构建的 BST 树具有唯一性:以 i 为根节点的树,其左子树由 [1, i-1] 构成,其右子树由 [i+1, n] 构成。
   
   可以得出Count的递推公式为

   Count(i) = \sum_{k = 1}^{i} Count(k - 1) * Count(i - k) 

   问题至此划归为一维动态规划。
#+BEGIN_SRC java
public int numTrees(int n) {
    int [] cnt = new int[n + 1];
    cnt[0] = 1; // empty element
    cnt[1] = 1; // one element
    for (int i = 2; i <= n ; i++) 
        for (int j = 0; j < i; j++) 
            cnt[i] += cnt[j]*cnt[i - 1 - j];
    return cnt[n];
}
#+END_SRC
*** Unique Binary Search Tree II
    Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.
    
    For example,
    
    Given n = 3, your program should return all 5 unique BST's shown below.
    #+BEGIN_SRC java
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
    #+END_SRC
#+BEGIN_SRC java
public List<TreeNode> helper(int bgn, int end) {
    List<TreeNode> res = new ArrayList<TreeNode>();
    if (bgn > end) {
        res.add(null);  // important
        return res;
    }

    List<TreeNode> left = null;
    List<TreeNode> right = null;
    TreeNode root = null;
    for (int i = bgn; i <= end ; i++) {
        left = helper(bgn, i - 1);
        right = helper(i + 1, end);
        for (int j = 0; j < left.size(); j++) {
            for (int k = 0; k < right.size(); k++) {
                root = new TreeNode(i);
                root.left = left.get(j);
                root.right = right.get(k);
                res.add(root);
                root = null;
            }
        }
        left = null;
        right = null;
    }
    return res;
}
        
public List<TreeNode> generateTrees(int n) {
    return helper(1, n);
}
#+END_SRC
*** Maximum Sum Subarray
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2, 1, -3, 4, -1, 2, 1, -5, 4], 

the contiguous subarray [4, -1, 2, 1] has the largest sum = 6.

click to show more practice.

*More practice:*

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

*Tags:* Divide and Conquer, Array, Dynamic Programming

分析:

最大连续子序列和,非常经典的题。

当我们从头到尾遍历这个数组的时候, 对于数组里的一个整数, 它有几种选择呢? 它只有两种选择: 1、加入之前的 SubArray;  2. 自己另起一个 SubArray。那什么时候会出现这两种情况呢?

- 如果之前 SubArray 的总体和大于 0 的话, 我们认为其对后续结果是有贡献的。这种情况下我们选择加入之前的 SubArray

- 如果之前 SubArray 的总体和为 0 或者小于 0 的话, 我们认为其对后续结果是没有贡献, 甚至是有害的(小于 0 时)。这种情况下我们选择以这个数字开始, 另起一个 SubArray。

设状态为 f[j], 表示以 S[j] 结尾的最大连续子序列和, 则状态转移方程如下:
#+BEGIN_SRC java
f[j] = max (f[j-1] + S[j], S[j]) , 其中 1 ≤ j ≤ n
target = max (f[j]) , 其中 1 ≤ j ≤ n
#+END_SRC

解释如下:

情况一, S[j]不独立, 与前面的某些数组成一个连续子序列, 则最大连续子序列和为 f[j-1] + S[j]。

情况二, S[j] 独立划分成为一段, 即连续子序列仅包含一个数 S[j], 则最大连续子序列和为S[j]。

其他思路:
- 思路 2: 直接在 i 到 j 之间暴力枚举, 复杂度是 O(n^3)
- 思路 3: 处理后枚举, 连续子序列的和等于两个前缀和之差, 复杂度 O(n^2)。
- 思路 4: 分治法, 把序列分为两段, 分别求最大连续子序列和, 然后归并, 复杂度 O( n*(log(n)) )
- 思路 5: 把思路 2 O(n^2) 的代码稍作处理, 得到 O(n) 的算法
- 思路 6: 当成 M = 1 的最大 M 子段和
**** 动态规划： 时间复杂度 O(n), 空间复杂度 O(1)
#+BEGIN_SRC java
public int maxSubArray(int[] a) {
    int result = Integer.MIN_VALUE, f = 0;
    for (int i = 0; i < a.length; i++) {
        f = Math.max(f + a[i], a[i]);
        result = Math.max(result, f);
    }
    return result;
}
#+END_SRC
**** 思路 5: 时间复杂度 O(n),空间复杂度 O(n)
#+BEGIN_SRC java
public int maxSubArray(int[] a) {
    int result, curMin;
    int [] sum = new int[a.length + 1];
    sum[0] = 0;
    result = Integer.MIN_VALUE;
    curMin = sum[0];
    for (int i = 1; i <= a.length; i++) 
        sum[i] = sum[i - 1] + a[i - 1];
    for (int i = 1; i <= a.length; i++) {
        result = Math.max(result, sum[i] - curMin);
        curMin = Math.min(curMin, sum[i]);
    }
    return result;
}
#+END_SRC
*** Maximum Product Subarray
Find the contiguous subarray within an array (containing at least one number) which has the largest product.

For example, given the array [2, 3, -2, 4], 

the contiguous subarray [2, 3] has the largest product = 6.

这道题跟[[Maximum Sum Subarray]]模型上和思路上都比较类似，还是用一维动态规划中的“局部最优和全局最优法”。

这里的区别是维护一个局部最优不足以求得后面的全局最优，这是由于乘法的性质不像加法那样，累加结果只要是正的一定是递增，乘法中有可能现在看起来小的一个负数，后面跟另一个负数相乘就会得到最大的乘积。

不过事实上也没有麻烦很多，我们只需要在维护一个局部最大的同时，在维护一个局部最小，这样如果下一个元素遇到负数时，就有可能与这个最小相乘得到当前最大的乘积和，这也是利用乘法的性质得到的。

来自《Code Ganker征服代码》

#+BEGIN_SRC java
public int maxProduct(int[] a) {
    int n = a.length;
    int maxLocal = a[0];
    int minLocal = a[0];
    int res = a[0];
    for (int i = 1; i < n; i++) {
        int tmp = maxLocal;
        maxLocal = Math.max(Math.max(maxLocal * a[i], a[i]),
                            Math.max(minLocal * a[i], a[i]));
        minLocal = Math.min(Math.min(a[i], a[i] * tmp),
                            Math.min(a[i], a[i] * minLocal));
        res = Math.max(res, maxLocal);
    }
    return res; 
}
#+END_SRC
*** Decode Ways, bug~~!!
A message containing letters from A-Z is being encoded to numbers using the following mapping:
#+BEGIN_SRC java
'A' -> 1
'B' -> 2
...
'Z' -> 26
#+END_SRC

Given an encoded message containing digits, determine the total number of ways to decode it.

For example,

Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

The number of ways decoding "12" is 2.

参考Climb stairs, [[Climbing Stairs]]

最原始型的follow、控制logic：
#+BEGIN_SRC java
public int numDecodings(String s) {
    if (s == null || s.length() == 0) return 0;
    else if (s.charAt(0) == '0') return 0;
    else if (s.length() == 1) return 1;
    else if (s.length() >= 2 && s.charAt(0) - '0' > 2 && s.charAt(1) == '0') return 0;
            
    int j = 0; // idx for s
    char c;    // char at pos j
    int [] res = new int[s.length()];
    res[0] = 1;
    res[1] = 1;
    if (s.charAt(1) != '0'
        && ( (s.charAt(0) == '1'
              || (s.charAt(0) == '2') && s.charAt(1) - '0' < 7)))
        res[1] = 2;
            
    for (int i = 2; i < s.length(); i++) {
        c = s.charAt(i);
        if (c != '0')
            res[i] += res[i - 1]; // separate dijit // except '0', NO, 10, 20 ok

        switch (c) {
        case '0':
            if (s.charAt(i - 1) == '1' || s.charAt(i - 1) == '2')
                if (s.charAt(i - 2) == '1' || s.charAt(i - 2) == '2')
                    res[i] = res[i - 2];     // 110 = 1 10, ... 11 0, NO~!
                else
                    res[i] = res[i - 1]; 
            else return 0;
            break;
        case '7':     // 17, 18, 19
        case '8':
        case '9':
            if (s.charAt(i - 1) == '1')
                res[i] += res[i - 2];
            break;
        default:     // 1, 2, 3, 4, 5, 6: Individual, 1-pre, 2-pre, 11, 21, 12, 22 ...
            if (s.charAt(i - 1) == '1' || s.charAt(i - 1) == '2')
                res[i] += res[i - 2];
            break;
        }
    }
    return res[s.length() - 1];
}
#+END_SRC
**** 动态规划, 时间复杂度 O(n), 空间复杂度 O(1), java v m bug ~~~~!!!!

模拟pdf c++版大牛精华版代码： 
#+BEGIN_SRC java
// my Java version code has bug here, fix it later ~~~
public int numDecodings(String s) {
    if (s == null || s.length() == 0 || s.charAt(0) == '0') return 0;
    int prev = 0;
    int curr = 1;
    int tmp = 0;
    for (int i = 1; i <= s.length() ; i++) {
        if (s.charAt(i - 1) == '0') curr = 0;
        if (i < 2 || s.charAt(i - 2) != '1' ||
            (s.charAt(i - 2) == '2' && s.charAt(i - 1) <= '6'))
            prev = 0;
        tmp = curr;
        curr = prev + curr;
        prev = tmp;
    }
    return curr;
}
#+END_SRC

*** Triangle
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle
#+BEGIN_SRC java
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
#+END_SRC

The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
**** 自顶向下： 时间复杂度是O(n^2)， 空间复杂度是O(n)

这是一道动态规划的题目，求一个三角形二维数组从顶到低端的最小路径和。思路是维护到某一个元素的最小路径和，那么在某一个元素i，j的最小路径和就是它上层对应的相邻两个元素的最小路径和加上自己的值，递推式是

sum[i][j] = min(sum[i-1][j-1],sum[i-1][j]) + triangle[i][j]。

最后扫描一遍最后一层的路径和，取出最小的即可。每个元素需要维护一次，总共有 1+2+...+n = n*(n+1)/2 个元素，所以时间复杂度是O(n^2)。而空间上每次只需维护一层即可（因为当前层只用到上一层的元素），所以空间复杂度是O(n)。

来自《Code Ganker征服代码》
#+BEGIN_SRC java
public int minimumTotal(ArrayList<ArrayList<Integer>> triangle) {  
    if(triangle == null || triangle.size() == 0)  
        return 0;  
    if(triangle.size() == 1)  
        return triangle.get(0).get(0);
    
    int[] dp = new int[triangle.size()];  
    dp[0] = triangle.get(0).get(0);  
    for(int i = 1; i < triangle.size(); i++) {  
        dp[i] = dp[i - 1] + triangle.get(i).get(i);  
        for(int j = i - 1 ; j >= 1; j--)  
            dp[j] = (dp[j] < dp[j-1] ? dp[j] : dp[j - 1]) + triangle.get(i).get(j);  
        dp[0] = dp[0] + triangle.get(i).get(0);  
    }
    
    int minimum = dp[0];  
    for(int i = 1; i < dp.length; i++) 
        if (dp[i] < minimum)
            minimum = dp[i];  
    return minimum;  
}
#+END_SRC

上述代码实现时要注意每层第一个和最后一个元素特殊处理一下。
**** 自底向上： 

换个角度考虑一下，如果这道题不自顶向下进行动态规划，而是放过来自底向上来规划，递归式只是变成下一层对应的相邻两个元素的最小路径和加上自己的值，原理和上面的方法是相同的，这样考虑到优势在于不需要最后对于所有路径找最小的，而且第一个元素和最后元素也不需要单独处理了，所以代码简洁了很多。
#+BEGIN_SRC java
public int minimumTotal(List<List<Integer>> triangle) {
    List<Integer> res = new ArrayList<Integer>(triangle.get(triangle.size() - 1));
    for (int i = triangle.size() - 2; i >= 0 ; i--) 
        for (int j = 0; j <= i ; j++) 
            res.set(j, Math.min(res.get(j), res.get(j + 1)) + triangle.get(i).get(j));
    return res.get(0);
}
#+END_SRC
*** Word Break
Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

For example, given
#+BEGIN_SRC java
s = "leetcode",
dict = ["leet", "code"].
Return true because "leetcode" can be segmented as "leet code".
#+END_SRC

设状态为 f(i),表示 s[0,i] 是否可以分词,则状态转移方程为

转移方程: f (i) = any_of ( f(j) && s[j+1, i] ∈ dict ), 0 ≤ j < i
**** 深搜: 时间复杂度 O(2^n),空间复杂度 O(n)

OJ 超时。
#+BEGIN_SRC java
public boolean helper(String s, int i, Set<String> dict) {
    int n = s.length();
    if (i >= n) return false;
    int j = i;
    while (j < n) {
        while (j < n && !dict.contains(s.substring(i, j + 1))) j++;
        if (j == n) return false;
        if (helper(s, j + 1, dict) == true) return true;
        j++;
    }
    return false;
}
        
public boolean wordBreak(String s, Set<String> dict) {
    if (dict.contains(s)) return true;
    if (s == null || s.length() == 0) return false;
    return helper(s, 0, dict);
}
#+END_SRC
**** 动态规划：
#+BEGIN_SRC java
public boolean wordBreak(String s, Set<String> dict) {
    if (dict.contains(s)) return true;
    boolean [] dp = new boolean[s.length()];
    for (int i = 0; i < s.length(); i++) 
        dp[i] = false;

    for (int i = 0; i < s.length(); i++)
        for (int j = i; j >= 0; j--) {
            String tmp = new String(s.substring(j, i+1));
            if (dict.contains(tmp))
                if ((j == 0) || (j >= 1 && dp[j-1])) {
                    dp[i] = true;
                    break;
                }
        }
    return dp[s.length()-1];
}
#+END_SRC

** Hard
*** Best Time to Buy and Sell Stock III
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

设状态 f(i), 表示区间[0, i](0 ≤ i ≤ n−1) 的最大利润, 状态 g(i), 表示区间[i, n−1](0 ≤ i ≤ n−1)的最大利润, 则最终答案为 max{ f(i) + g(i) }, 0 ≤ i ≤ n−1。

允许在一天内买进又卖出,相当于不交易,因为题目的规定是最多两次,而不是一定要两次。

将原数组变成差分数组, 本题也可以看做是最大 m 子段和, m = 2.

#+BEGIN_SRC java
public int maxProfit(int[] prices) {
    if (prices.length < 2) return 0; 
    int [] past = new int[prices.length];
    int [] futu = new int[prices.length];
    int result = 0;
    for (int i = 1, valley = prices[0]; i < prices.length; i++) {
        valley = Math.min(valley, prices[i]);
        past[i] = Math.max(past[i - 1], prices[i]-valley);
    }
    for (int i = prices.length-2, peak = prices[prices.length-1]; i >= 0 ; i--) {
        peak = Math.max(peak, prices[i]);
        futu[i] = Math.max(futu[i+1], peak-prices[i]);
        result = Math.max(result, past[i] + futu[i]);
    }
    return result;
}
#+END_SRC

*** Coins in a Line

*** Edit Distance
Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)

You have the following 3 operations permitted on a word:

a) Insert a character

b) Delete a character

c) Replace a character

设状态为 f[i][j], 表示 A[0, i] 和 B[0, j] 之间的最小编辑距离。设 A[0, i] 的形式是 str1c, B[0, j] 的形式是 str2d, 

一. 如果 c == d, 则 f[i][j] = f[i-1][j-1];

二. 如果 c != d,
 
  (a) 如果将 c 替换成 d, 则\nbsp{} \nbsp{} \nbsp{} \nbsp{} \nbsp{} \nbsp{} f[i][j] = f[i-1][j-1] + 1;

  (b) 如果在 c 后面添加一个 d, 则\nbsp{} f[i][j] = f[i][j-1] + 1;

  (c) 如果将 c 删除, 则\nbsp{} \nbsp{} \nbsp{} \nbsp{} \nbsp{} \nbsp{} \nbsp{} \nbsp{} \nbsp{} f[i][j] = f[i-1][j] + 1;

**** 动态规划：时间复杂度 O(n*m), 空间复杂度 O(n*m)。
#+BEGIN_SRC java
public int minDistance(String s, String t) {
    int m = s.length();
    int n = t.length();
    int [][] res = new int[m + 1][n + 1];
    for (int i = 0; i <= m; i++)
        res[i][0] = i;
    for (int i = 0; i <= n; i++)
        res[0][i] = i;
    for (int i = 1; i <= m; i++) 
        for (int j = 1; j <= n; j++) 
            if (s.charAt(i - 1) == t.charAt(j - 1))
                res[i][j] = res[i - 1][j - 1];
            else 
                res[i][j] = Math.min(Math.min(res[i - 1][j], res[i][j - 1]),
                                     Math.min(res[i - 1][j], res[i - 1][j - 1])) + 1;
    return res[m][n];
#+END_SRC
**** 动态规划 + 滚动数组：

*** Distinct Subsequence
Given a string S and a string T, count the number of distinct subsequences of T in S.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

Here is an example:

S = "rabbbit", T = "rabbit"

Return 3.

设状态为 f(i, j), 表示 T[0, j] 在 S[0, i] 里出现的次数。首先, 无论 S[i] 和 T[j] 是否相等, 

若不使用 S[i], 则\nbsp \nbsp \nbsp \nbsp \nbsp \nbsp \nbsp \nbsp \nbsp \nbsp \nbsp \nbsp \nbsp f(i, j) = f(i-1, j); 

若 S[i] == T[j], 则可以使用 S[i], 则 f(i, j) = f(i-1, j) + f(i-1, j-1)。

#+BEGIN_SRC java
public int numDistinct(String s, String t) {
    if (s == null || s.length() == 0) return 0;
    int m = s.length();
    int n = t.length();
    int [][] res = new int[m + 1][n + 1];
    for (int i = 0; i <= m; i++) 
        res[i][0] = 1;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s.charAt(i - 1) == t.charAt(j - 1))
                res[i][j] = res[i - 1][j] + res[i - 1][j - 1];
            else
                res[i][j] = res[i - 1][j];
        }
    }
    return res[m][n];
}
#+END_SRC

滚动数组： 时间复杂度 O(m*n), 空间复杂度 O(n)
#+BEGIN_SRC java
public int numDistinct(String s, String t) {
    if (s == null || s.length() == 0) return 0;
    int m = s.length();
    int n = t.length();
    int [] res = new int[n + 1];
    res[0] = 1;
    for (int i = 0; i < m; i++) 
        for (int j = n - 1; j >= 0; j--) 
            res[j + 1] += s.charAt(i) == t.charAt(j) ? res[j] : 0;
    return res[n];
}
#+END_SRC

*** Palindrome Partitioning II 
Given a string s, partition s such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of s.

For example, 
#+BEGIN_SRC java
given s = "aab",
Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut.
#+END_SRC

*** Interleaving String
Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

For example, Given:
#+BEGIN_SRC java
s1 = "aabcc",
s2 = "dbbca",
When s3 = "aadbbcbcac", return true.
When s3 = "aadbbbaccc", return false.
#+END_SRC

*** Scramble String
    Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

    Below is one possible representation of s1 = "great":

    #+BEGIN_SRC java
    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
    #+END_SRC

    To scramble the string, we may choose any non-leaf node and swap its two children.
    
    For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".

    #+BEGIN_SRC java
    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
    #+END_SRC

    We say that "rgeat" is a scrambled string of "great".
    
    Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".

    #+BEGIN_SRC java
    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
    #+END_SRC    

    We say that "rgtae" is a scrambled string of "great".
    
    Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

*** Regular Expression Matching
Implement regular expression matching with support for '.' and '*'.
#+BEGIN_SRC java
'.' Matches any single character.
'*' Matches zero or more of the preceding element.
#+END_SRC

The matching should cover the entire input string (not partial).

The function prototype should be:

bool isMatch(const char *s, const char *p)

Some examples:
#+BEGIN_SRC java
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true
#+END_SRC

*Tags:* Dynamic Programming Backtracking String

*** Wildcard Matching
Implement wildcard pattern matching with support for '?' and '*'.
#+BEGIN_SRC java
'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
#+END_SRC

The matching should cover the entire input string (not partial).

The function prototype should be:

bool isMatch(const char *s, const char *p)

Some examples:
#+BEGIN_SRC java
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
#+END_SRC

*Tags:* Dynamic Programming, Backtracking, Greedy, String

** others Covered
- Best Time to Buy and Sell Stock
  [[Best Time to Buy and Sell Stock]]
- Best Time to Buy and Sell Stock II
  [[Best Time to Buy and Sell Stock II]]
- Longest Valid Parentheses
  [[Longest Valid Parentheses]]
- Word Break II
  [[Word Ladder II]]
- Maximum Rectangle
  [[Maximum Rectangle]]

* Two Pointers and Sliding Window
** Easy
*** Valid Palindrome
*** Remove Nth Node From End of List
*** Remove Element
*** Remove Duplicates from Sorted Array
*** Merge Sorted Array
*** Implement strStr()
** Medium
*** 3Sum
*** 4Sum
*** Container With Most Water
*** Remove Duplicates from Sorted Array II
*** Partition List	
*** Two Sum II - Input array is sorted
*** Linked List Cycle II
*** Longest Substring Without Repeating Characters
*** 3Sum Closest
*** Linked List Cycle
*** Sort Colors
*** Rotate List
** Hard
*** Trapping Rain Water
*** Longest Substring with At Most Two Distinct Characters
*** Substring with Concatenation of All Words	
*** Minimum Window Substring
* Backtracing and Recursion
** 排列
*** Permutation
Given a collection of numbers, return all possible permutations.

For example,
#+BEGIN_SRC java
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
#+END_SRC
*** Permutation II
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example,
#+BEGIN_SRC java
[1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1].
#+END_SRC
*** Permutation Sequence
The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3):
#+BEGIN_SRC java
"123"
"132"
"213"
"231"
"312"
"321"
#+END_SRC
Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.
** 组合
*** Combinationas
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

For example,

If n = 4 and k = 2, a solution is:
#+BEGIN_SRC java
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
#+END_SRC
*** Combination Sum
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers added to T.

The same repeated number may be chosen from C unlimited number of times.

Note:
- All numbers (including target) will be positive integers.
- Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
- The solution set must not contain duplicate combinations.

For example, given candidate set 2,3,6,7 and target 7, 

A solution set is: 
#+BEGIN_SRC java
[7] 
[2, 2, 3] 
#+END_SRC
*** Combination Sum II
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers added to T.

Each number in C may only be used once in the combination.

Note:
- All numbers (including target) will be positive integers.
- Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
- The solution set must not contain duplicate combinations.
For example, given candidate set 10,1,2,7,6,1,5 and target 8, 

A solution set is: 
#+BEGIN_SRC java
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 
#+END_SRC
** Subsets
*** Subsets: Bit Manipulation
Given a set of distinct integers, S, return all possible subsets.

Note:
- Elements in a subset must be in non-descending order.
- The solution set must not contain duplicate subsets.
For example,

If S = [1,2,3], a solution is:
#+BEGIN_SRC java
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
#+END_SRC
*Tags:* Array Backtracking, Bit Manipulation
*** Subsets II
Given a collection of integers that might contain duplicates, S, return all possible subsets.

Note:
- Elements in a subset must be in non-descending order.
- The solution set must not contain duplicate subsets.
For example,

If S = [1,2,2], a solution is:
#+BEGIN_SRC java
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
#+END_SRC
** others with Recursion
*** Letter Combinationas of Phone Number
Given a digit string, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below.

#+CAPTION: Letter Combinationas of Phone Number
[[./pic/phoneNumber.png]]
#+BEGIN_SRC java
Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
#+END_SRC
Note:

Although the above answer is in lexicographical order, your answer could be in any order you want.
*** Restore IP Addresses
Given a string containing only digits, restore it by returning all possible valid IP address combinations.

For example:
#+BEGIN_SRC java
Given "25525511135",
return ["255.255.11.135", "255.255.111.35"]. (Order does not matter)
#+END_SRC
*** Generate Parentheses
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:
#+BEGIN_SRC java
"((()))", "(()())", "(())()", "()(())", "()()()"
#+END_SRC
*** Gray Code
The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
#+BEGIN_SRC java
00 - 0
01 - 1
11 - 3
10 - 2
#+END_SRC
Note:
- For a given n, a gray code sequence is not uniquely defined.
- For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.
- For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.
*** Word Search
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
#+BEGIN_SRC java
Given board =
[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]
word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.
#+END_SRC
*** Palindrome Partitioning 
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

For example, 
#+BEGIN_SRC java
given s = "aab",
Return
  [
    ["aa","b"],
    ["a","a","b"]
  ]
#+END_SRC
*** N-Queens 
The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
 #+caption: N-Queens 
[[./pic/8-queens.png]]

Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

For example,

There exist two distinct solutions to the 4-queens puzzle:
#+BEGIN_SRC java
[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
#+END_SRC
*** N-Queens II
Follow up for N-Queens problem.

Now, instead outputting board configurations, return the total number of distinct solutions.
*** Sudoku Solver
    Write a program to solve a Sudoku puzzle by filling the empty cells.
    
    Empty cells are indicated by the character '.'.
    
    You may assume that there will be only one unique solution.
    
    #+caption: Sudoku Solver 1
    [[./pic/solveSudoku1.png]]

    A sudoku puzzle...
    
    #+caption: Sudoku Solver 2
    [[./pic/solveSudoku2.png]]
    ...and its solution numbers marked in red.
    
    *Tags:* Backtracking, Hash Table

*** Regular Expression Matching
Implement regular expression matching with support for '.' and '*'.
- '.' Matches any single character.
- '*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:

bool isMatch(const char *s, const char *p)

Some examples:
#+BEGIN_SRC java
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true
#+END_SRC
*Tags:* Dynamic Programming, Backtracking, String
*** Wild Card Matching
Implement wildcard pattern matching with support for '?' and '*'.
- '?' Matches any single character.
- '*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:

bool isMatch(const char *s, const char *p)

Some examples:
#+BEGIN_SRC java
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
#+END_SRC
*Tags:* Dynamic Programming, Backtracking, Greedy, String
*** Word Break II
Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.

Return all such possible sentences.

For example, given
#+BEGIN_SRC java
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].

A solution is ["cats and dog", "cat sand dog"].
#+END_SRC
*Tags:* Dynamic Programming Backtracking
*** Word Ladder II
Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:
- Only one letter can be changed at a time
- Each intermediate word must exist in the dictionary
For example,
#+BEGIN_SRC java
Given:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
#+END_SRC
Note:
- All words have the same length.
- All words contain only lowercase alphabetic characters.
*Tags:* Array, Backtracking, Breadth-first Search, String

* Bit Manipulation
** Easy
*** Majority Element
    Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
    
    You may assume that the array is non-empty and the majority element always exist in the array.
    
    Credits:
    
    Special thanks to @ts for adding this problem and creating all test cases.
    
    *Tags:* Divide and Conquer, Array, Bit Manipulation

** Medium
*** Subsets: Bit Manipulation
Given a set of distinct integers, S, return all possible subsets.

Note:
- Elements in a subset must be in non-descending order.
- The solution set must not contain duplicate subsets.
For example,
If S = [1,2,3], a solution is:
#+BEGIN_SRC java
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
#+END_SRC
*Tags:* Array Backtracking, Bit Manipulation
*** Single Number
    Given an array of integers, every element appears twice except for one. Find that single one.
    
    Note:
    
    Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
    
    *Tags:* Hash Table, Bit Manipulation

*** Single Number II
    Given an array of integers, every element appears three times except for one. Find that single one.

    Note:
    
    Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

* 图 Graphics
** Medium
*** Clone Graph
   Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
   
   OJ's undirected graph serialization:

   Nodes are labeled uniquely.
   
   We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.

   As an example, consider the serialized graph {0,1,2#1,2#2,2}.
   
   The graph has a total of three nodes, and therefore contains three parts as separated by #.
   
   1. First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
   2. Second node is labeled as 1. Connect node 1 to node 2.
   3. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.

Visually, the graph looks like the following:
[[./pic/clonegraph.jpg]]

**** 分析： 广度优先遍历或深度优先遍历都可以
**** DFS： 时间复杂度O(n), 空间复杂度O(n)
#+BEGIN_SRC java 
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    UndirectedGraphNode res = new UndirectedGraphNode(node.label);  // result head
    if (node.neighbors == null || node.neighbors.size() == 0) return res;

    Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
    Queue<UndirectedGraphNode> q = new LinkedList<UndirectedGraphNode>();
    q.add(node);                      // added first node, need add its all Neighbors as well
    map.put(node, res);

    List<UndirectedGraphNode> curNbr = new ArrayList<UndirectedGraphNode>();
    UndirectedGraphNode curr = null;
    while (!q.isEmpty()) {
        curr = q.poll();
        curNbr = curr.neighbors;                   // ori
        for (UndirectedGraphNode aNbr : curNbr) {  // for build connection among copies
            if (!map.containsKey(aNbr)) {
                UndirectedGraphNode acpNbr = new UndirectedGraphNode(aNbr.label);
                map.put(aNbr, acpNbr);
                map.get(curr).neighbors.add(acpNbr);
                q.add(aNbr);
            } else
                map.get(curr).neighbors.add(map.get(aNbr));                        
        }
    }
    return res;
}
#+END_SRC 
**** BFS：
** Word Ladder, Word Ladder II: Backtracing
*** Word Ladder
Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:
1. Only one letter can be changed at a time
2. Each intermediate word must exist in the dictionary

For example,

Given:
start = "hit", end = "cog"

dict = ["hot","dot","dog","lot","log"]

As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",

return its length 5.

Note:
- Return 0 if there is no such transformation sequence.
- All words have the same length.
- All words contain only lowercase alphabetic characters.

*** Word Ladder II
Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:
1. Only one letter can be changed at a time
2. Each intermediate word must exist in the dictionary
For example,

Given:

start = "hit", end = "cog"

dict = ["hot","dot","dog","lot","log"]

Return
#+BEGIN_SRC java
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
#+END_SRC

Note:
- All words have the same length.
- All words contain only lowercase alphabetic characters.

*** Check whether the graph is bigraph
**** Topological Sort
Topological sorting for Directed Acyclic Graph (DAG) is a linear
ordering of vertices such that for every directed edge uv, vertex u
comes before v in the ordering. Topological Sorting for a graph is not
possible if the graph is not a DAG.

For example, a topological sorting of the following graph is “5 4 2 3
1 0″. There can be more than one topological sorting for a graph. For
example, another topological sorting of the following graph is “4 5 2
3 1 0″. The first vertex in topological sorting is always a vertex
with in-degree as 0 (a vertex with no in-coming edges).
#+CAPTION: Topological Sorting
[[./pic/topologicalSorting.png]]
**** Topological Sorting vs Depth First Traversal (DFS):
In DFS, we print a vertex and then recursively call DFS for its adjacent vertices. In topological sorting, we need to print a vertex before its adjacent vertices. For example, in the given graph, the vertex ‘5’ should be printed before vertex ‘0’, but unlike DFS, the vertex ‘4’ should also be printed before vertex ‘0’. So Topological sorting is different from DFS. For example, a DFS of the above graph is “5 2 3 1 0 4″, but it is not a topological sorting.
**** Algorithm to find Topological Sorting:
We recommend to first see implementation of DFS here. We can modify DFS to find Topological Sorting of a graph. In DFS, we start from a vertex, we first print it and then recursively call DFS for its adjacent vertices. In topological sorting, we use a temporary stack. We don’t print the vertex immediately, we first recursively call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of stack. Note that a vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on) are already in stack.

* Data Structure
** Easy
*** Two Sum III
Design and implement a TwoSum class. It should support the following operations: add and find.
- add - Add the number to an internal data structure.
- find - Find if there exists any pair of numbers which sum is equal to the value.
For example,
#+BEGIN_SRC java
add(1); add(3); add(5);
find(4) -> true
find(7) -> false
#+END_SRC
*Tags:* Hash Table, Data Structure
#+BEGIN_SRC java

#+END_SRC

*** Min Stack
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
- push(x) -- Push element x onto stack.
- pop() -- Removes the element on top of the stack.
- top() -- Get the top element.
- getMin() -- Retrieve the minimum element in the stack.
 *Tags:* Stack Data Structure
#+BEGIN_SRC java
public static class MinStack {
    Stack<Integer> stack = new Stack<Integer>();
    Stack<Integer> minStack = new Stack<Integer>();
    public void push(int x) {
        stack.push(x);
        if (minStack.isEmpty() || x <= minStack.peek()) {
            minStack.push(x);
        }
    }

    public void pop() { // java boxing & unboxing, container, object specific methods
        if (stack.peek().intValue() == minStack.peek().intValue()) 
            minStack.pop();
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        if (!minStack.isEmpty()) return minStack.peek();
        else return -1;
    }
}
#+END_SRC
** Hard
*** LRU Cache
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.
- get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
- set(key, value) - Set or insert the value if the key is not already
  present. When the cache reached its capacity, it should invalidate
  the least recently used item before inserting a new item.
#+BEGIN_SRC java
public static class LRUCache {
    public class Node {
        int key;
        int value;
        Node prev;
        Node next;
        public Node(int x, int y){
            key = x;
            value = y;
        }
    }

    private HashMap<Integer, Node> hash;
    private int cap;
    private int number;
    Node head;
    Node tail;
    public LRUCache(int capacity) {
        cap = capacity;
        number = 0;
        head = new Node(-1, -1);
        head.prev = null;
        head.next = null;
        tail = head;
        hash = new HashMap<Integer, Node>(capacity); // so I can restrict a size !!
    }
    
    public int get(int key) {
        Node res = hash.get(new Integer(key)); // don't understand here
        if (res != null) {
            refresh(res);   // update usage frequence
            return res.value;
        } else return -1;
        /*
          if (hash.containsKey(key)) {
          //Node res = hash.get(new Integer(key)); // don't understand here
          Node res = hash.get(key);
          refresh(res);   // update usage frequence
          return res.value;
          } else {
          return -1;
          }
        */
    }

    // so still, must maintain a doubly-linked list to order usage frequency
    public  void refresh(Node tmp) {
        if (tmp == head.next) return; // it's head already
            
        Node temp = head.next;  // head node in the hash
        Node prevNode = tmp.prev;
        Node nextNode = tmp.next;
        // set to be most recently used~~ move the tmp node to be head.next, connections
        head.next = tmp;  
        tmp.prev = head;
        tmp.next = temp;
        temp.prev = tmp;
        prevNode.next = nextNode;
        if (nextNode != null) 
            nextNode.prev = prevNode;
        else tail = prevNode;   // remember tail as well 
    }

    public void set(int key, int value) {
        Node res = hash.get(new Integer(key));
        if (res != null) {
            refresh(res);
            res.value = value;
        } else {
            //if (!hash.containsKey(key)) { // another way of detecting existing
            Node prevNode = new Node(key, value); 
            Node temp;
            if (number == cap) { // remove tail;
                temp = tail.prev;
                hash.remove(tail.key);      // remember to remove from hash too !!!
                if (temp != null) {
                    temp.next = null;
                }
                tail.prev = null;
                tail = temp;
                number--;
            }
            // add to tail first
            tail.next = prevNode;
            prevNode.prev = tail;
            tail = prevNode;
            refresh(prevNode);
            hash.put(key, prevNode); 
            number++;  // count node numbers
        }
    }
}
#+END_SRC
* 细节实现题

* Math
** Easy
*** Add Binary
*** Roman to Integers
*** String to Integer (atoi)
*** Palindrome Number
*** Plus One
    
*** Factorial Trailing Zeroes
*** Excel Sheet Column Title
*** Excel Sheet Column Number
*** Reverse Integer
** Medium
*** Multiply Strings
*** Sqrt(x)
*** Divide Two Integers
*** Pow(x, n)	
*** Fraction to Recurring Decimal
*** Permutation Sequence	
*** Integer to Roman
*** Next Permutation: Math
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its
corresponding outputs are in the right-hand column.
#+BEGIN_SRC java
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
#+END_SRC

** Hard
*** Valid Number
*** Max Points on a Line
