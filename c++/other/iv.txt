发信人: bluesun (老小虎), 信区: JobHunting
标  题: Re: 如何做LeetCode
发信站: BBS 未名空间站 (Mon Jan  7 17:01:56 2013, 美东)

我其实最近才开始做leetcode，一周时间，到现在刚好50题。我先来抛块砖吧，讲讲自己的体会：

1. 先看思路领会透不透。譬如说peranthese matching, largest rectangle, maximumrectangle 这些题。还有kth largest, median of two sorted arrays。特别是median of two sorted arrays，思路和细节吃透了， 再要写一遍的话，bug free并不算特别难。当然我是指“再写一遍”。我知道peking2的目标可能是没见过面的5分题一次写对:)，那可真得下功夫。

2. 再看固定模式熟不熟。tree的recursive，string matching的dp，math里用的移位和二分法，数组的左右指针，单链表的双指针traverse/delete。这些基本的东西要有敏感度。

3. corner case要cover够。空指针，0长度，integer记住有负数，unsigned包括0，duplicate怎么处理，会不会overflow，out of range，loop能不能terminate，recursive的basic case有几个。



发信人: tweedy2003 (tweedy), 信区: JobHunting
标  题: 面经 （谷家）
发信站: BBS 未名空间站 (Wed Jul 18 16:54:05 2012, 美东)

第一个: 题目比较通俗，给你一个二岔树的顺序遍历结果，还有前续遍历结果，把树还原出来


第二个 Conway's Game of Life.

告诉我一个游戏，叫做“生／或者／死”，在一个棋盘上，规则如下：

每格有两种状态：生，或者 死

每一轮，如果有少于两个邻居是活着的，这格就死掉
如果刚好有两个邻居活着，这格保持原有状态
如果有三个邻居活着，这格可以重生，就是如果原来是死的，现在活过来了
如果有三个以上邻居，这格就被挤死了

要在白板上写每轮如何更新整个棋盘的状态


Create a separate matrix and record new state of each cell, then start from 
there for next round ??
【 在 dustin (青蛙) 的大作中提到: 】
: 求第二题的思路，反复的扫描棋盘，直到没有状态改变吗？


第三个： 给一个矩阵，顺时针翻转九十度

第四个： 问了给了一些数轴上的范围，要求把重合的部分合并掉

最后一个

原来打算问生或者死的那题，结果发现被人抢了，很无语，于是改问零散的数学问题

估计一下谷歌地球总共要多大的硬盘来存全球的地貌照片。

一个很大的文件（一个billion），有很多行，每行长短不一，如何随机抽取一百行。假设你有一个六十四位的比特的随机数生成器。



发信人: starapi (STAR test API), 信区: JobHunting
标  题: G面试题，很难
发信站: BBS 未名空间站 (Sat Jan  4 16:13:39 2014, 美东)

4位的密码，遍历完所有0000-9999的可能性后，锁就能打开。

把所有的可能密码连接在一起成为总长度为4*10000=40000的string。这个string的某连续四位肯定能够能解开锁。

上面的string不是唯一的。比如实际密码是2345，string的某5位是12345，1234是一个组合，2345是另一个组合。也就是说他们共享了一些数字。导致总长度降低。

现在求一个最短的string，其中某连续4位一定是可以解开锁的密码。

发信人: fatalme (don't ever give it up), 信区: JobHunting
标  题: Re: G面试题，很难
发信站: BBS 未名空间站 (Sat Jan  4 16:37:32 2014, 美东)
deBrujin cycle.

发信人: jcolinzheng (Colin Jia Zheng), 信区: JobHunting
标  题: Re: G面试题，很难
发信站: BBS 未名空间站 (Sun Jan  5 01:30:10 2014, 美东)
This is not gray code.  No need to formulate it as TSP.  Also, debrujin graph only gives you a problem formulation.  
You can solve by finding an Eulerian tour.  Each node is a 3-digit number eg 100, and two nodes 100 and 001 are adjacent if they can be combined into 1001.  Now every node has equal in-degree and out-degree, thus an Eulerien tour exists and can be found using the standard algorithm.

发信人: PL2012 (Starcraft), 信区: JobHunting
标  题: Re: G面试题，很难
发信站: BBS 未名空间站 (Sun Jan  5 01:48:31 2014, 美东)
没看懂为啥是欧拉，不是哈密顿回路么，每个NODE是四位数，边是重复的字母
1001 => 1002, 3
1832 => 2321, 2
不应该是找条回路，穿过所有NODE，MAX PATH WEIGHT，就是TSP啊

发信人: jcolinzheng (Colin Jia Zheng), 信区: JobHunting
标  题: Re: G面试题，很难
发信站: BBS 未名空间站 (Sun Jan  5 10:43:29 2014, 美东)
Eulerian tour没有走多。看了我写的方法？关键是让每个edge是四位数，而不是node

发信人: PL2012 (Starcraft), 信区: JobHunting
标  题: Re: G面试题，很难
发信站: BBS 未名空间站 (Sun Jan  5 12:08:11 2014, 美东)
这写错了，应该是
1100=>1002,3 (选这个路径相当于合并成11002)
1823=>2321,2 （选这个路径相当于合并成182321)

发信人: MaGongJia (code farmer one), 信区: JobHunting
标  题: Re: G面试题，很难
发信站: BBS 未名空间站 (Mon Jan  6 17:29:47 2014, 美东)
G家题目难道都要你事先知道什么deBrujin cycle才做得出来？
这里多少人认为自己事先不知道deBrujin cycle能当场figure out出来？

发信人: MaGongJia (code farmer one), 信区: JobHunting
标  题: Re: G面试题，很难
发信站: BBS 未名空间站 (Tue Jan  7 00:46:27 2014, 美东)
我老编了个程序验证过了，基本只要一位一位算过去，如果不行就backtracking就行了，其实需要backtracking的情况很少。
基本只要1003个字符就可以了，而且首尾可以衔接，也就是说一个1000的环就可以了



发信人: nullpointer (nullpointer), 信区: JobHunting
标  题: Amazon面试题   search: 有很多讨论
发信站: BBS 未名空间站 (Mon Apr  8 18:09:15 2013, 美东)

上周面的，已杯具。有些题不记得了，说点记得的。

第一个是Sr manager，问了工作经历，然后让设计Facebook的news feed，回答用long polling来达到实时性。被问到这样的话连接太多，回答说用pub/sub来接收消息，再用long polling来把消息传给web。面得一般，不好也不是太坏。

第二个是Sr SDE。有一组records，每个record由三个参数组成，开始时间，结束时间，权重。找到一个set，这个set包含的records在时间上没有重叠，并且set的权重之和最大。一下子想不到好解法，被一直催着写代码，结果连最简单的都写错。还和面试官争论。面试结束时想到把这个问题变化成图来解决，每个record是图中的节点，如果两个records没有时间上的重叠，就有一条边，最后找到所有的clique，计算权重之和，返回权重之和最大的。面试官听了，没什么表情，问了问时间复杂度，说这样大概可行。这个是面的最差的，我觉得他大概都想把我给直接赶出去。

第三个是SDE，从多个数中找到最大的k个。开始用的是max heap，被指出后，改正为min heap。还问了些别的，都不难。

第四个是Sr SDE。问如何scale up一个系统，有web前端，数据库，后端模块通过消息通信。给出一些扩展的方法，看起来他比较满意，相互讨论多过问问题。然后让设计一个系统，通过电话号码找到人，用了B+ tree，让解释B+ tree的创建和优化。

第五个是Sr SDE，给一个数组，一个数X，找到数组中每一对加起来等于X的数。先给出经典答案，用hash，时间复杂度O(n)。追问如果不允许用额外的内存，讲了两个解法，一个是扫描数组，如果这个数小于X的一半，用X减去这个数的差来代替这个数，然后排序，再扫描数组，找到临近值相等的数。另一个是排序，扫描数组，对每一个数Y，折半查找X-Y。然后让白板写程序，还不错，一次写对，没有bug。还问了别的题，都不难
。
